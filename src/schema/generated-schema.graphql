# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Agency {
    _count: AgencyCount
    agencyId: Int!
    agencyLang: String!
    agencyName: String!
    agencyPhone: String!
    agencyTimezone: String!
    agencyUrl: String!
    routes(
        cursor: RouteWhereUniqueInput
        distinct: [RouteScalarFieldEnum!]
        orderBy: [RouteOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: RouteWhereInput
    ): [Route!]!
}

type AgencyAvgAggregate {
    agencyId: Float
}

input AgencyAvgOrderByAggregateInput {
    agencyId: SortOrder
}

type AgencyCount {
    routes: Int!
}

type AgencyCountAggregate {
    _all: Int!
    agencyId: Int!
    agencyLang: Int!
    agencyName: Int!
    agencyPhone: Int!
    agencyTimezone: Int!
    agencyUrl: Int!
}

input AgencyCountOrderByAggregateInput {
    agencyId: SortOrder
    agencyLang: SortOrder
    agencyName: SortOrder
    agencyPhone: SortOrder
    agencyTimezone: SortOrder
    agencyUrl: SortOrder
}

type AgencyGroupBy {
    _avg: AgencyAvgAggregate
    _count: AgencyCountAggregate
    _max: AgencyMaxAggregate
    _min: AgencyMinAggregate
    _sum: AgencySumAggregate
    agencyId: Int!
    agencyLang: String!
    agencyName: String!
    agencyPhone: String!
    agencyTimezone: String!
    agencyUrl: String!
}

type AgencyMaxAggregate {
    agencyId: Int
    agencyLang: String
    agencyName: String
    agencyPhone: String
    agencyTimezone: String
    agencyUrl: String
}

input AgencyMaxOrderByAggregateInput {
    agencyId: SortOrder
    agencyLang: SortOrder
    agencyName: SortOrder
    agencyPhone: SortOrder
    agencyTimezone: SortOrder
    agencyUrl: SortOrder
}

type AgencyMinAggregate {
    agencyId: Int
    agencyLang: String
    agencyName: String
    agencyPhone: String
    agencyTimezone: String
    agencyUrl: String
}

input AgencyMinOrderByAggregateInput {
    agencyId: SortOrder
    agencyLang: SortOrder
    agencyName: SortOrder
    agencyPhone: SortOrder
    agencyTimezone: SortOrder
    agencyUrl: SortOrder
}

input AgencyOrderByWithAggregationInput {
    _avg: AgencyAvgOrderByAggregateInput
    _count: AgencyCountOrderByAggregateInput
    _max: AgencyMaxOrderByAggregateInput
    _min: AgencyMinOrderByAggregateInput
    _sum: AgencySumOrderByAggregateInput
    agencyId: SortOrder
    agencyLang: SortOrder
    agencyName: SortOrder
    agencyPhone: SortOrder
    agencyTimezone: SortOrder
    agencyUrl: SortOrder
}

input AgencyOrderByWithRelationInput {
    agencyId: SortOrder
    agencyLang: SortOrder
    agencyName: SortOrder
    agencyPhone: SortOrder
    agencyTimezone: SortOrder
    agencyUrl: SortOrder
    routes: RouteOrderByRelationAggregateInput
}

input AgencyRelationFilter {
    is: AgencyWhereInput
    isNot: AgencyWhereInput
}

enum AgencyScalarFieldEnum {
    agencyId
    agencyLang
    agencyName
    agencyPhone
    agencyTimezone
    agencyUrl
}

input AgencyScalarWhereWithAggregatesInput {
    AND: [AgencyScalarWhereWithAggregatesInput!]
    NOT: [AgencyScalarWhereWithAggregatesInput!]
    OR: [AgencyScalarWhereWithAggregatesInput!]
    agencyId: IntWithAggregatesFilter
    agencyLang: StringWithAggregatesFilter
    agencyName: StringWithAggregatesFilter
    agencyPhone: StringWithAggregatesFilter
    agencyTimezone: StringWithAggregatesFilter
    agencyUrl: StringWithAggregatesFilter
}

type AgencySumAggregate {
    agencyId: Int
}

input AgencySumOrderByAggregateInput {
    agencyId: SortOrder
}

input AgencyWhereInput {
    AND: [AgencyWhereInput!]
    NOT: [AgencyWhereInput!]
    OR: [AgencyWhereInput!]
    agencyId: IntFilter
    agencyLang: StringFilter
    agencyName: StringFilter
    agencyPhone: StringFilter
    agencyTimezone: StringFilter
    agencyUrl: StringFilter
    routes: RouteListRelationFilter
}

input AgencyWhereUniqueInput {
    agencyId: Int
}

type AggregateAgency {
    _avg: AgencyAvgAggregate
    _count: AgencyCountAggregate
    _max: AgencyMaxAggregate
    _min: AgencyMinAggregate
    _sum: AgencySumAggregate
}

type AggregateCalendar {
    _count: CalendarCountAggregate
    _max: CalendarMaxAggregate
    _min: CalendarMinAggregate
}

type AggregateCalendarDate {
    _count: CalendarDateCountAggregate
    _max: CalendarDateMaxAggregate
    _min: CalendarDateMinAggregate
}

type AggregateRoute {
    _avg: RouteAvgAggregate
    _count: RouteCountAggregate
    _max: RouteMaxAggregate
    _min: RouteMinAggregate
    _sum: RouteSumAggregate
}

type AggregateShape {
    _count: ShapeCountAggregate
    _max: ShapeMaxAggregate
    _min: ShapeMinAggregate
}

type AggregateShapeSequence {
    _avg: ShapeSequenceAvgAggregate
    _count: ShapeSequenceCountAggregate
    _max: ShapeSequenceMaxAggregate
    _min: ShapeSequenceMinAggregate
    _sum: ShapeSequenceSumAggregate
}

type AggregateStop {
    _avg: StopAvgAggregate
    _count: StopCountAggregate
    _max: StopMaxAggregate
    _min: StopMinAggregate
    _sum: StopSumAggregate
}

type AggregateStopTime {
    _avg: StopTimeAvgAggregate
    _count: StopTimeCountAggregate
    _max: StopTimeMaxAggregate
    _min: StopTimeMinAggregate
    _sum: StopTimeSumAggregate
}

type AggregateTransfer {
    _avg: TransferAvgAggregate
    _count: TransferCountAggregate
    _max: TransferMaxAggregate
    _min: TransferMinAggregate
    _sum: TransferSumAggregate
}

type AggregateTrip {
    _count: TripCountAggregate
    _max: TripMaxAggregate
    _min: TripMinAggregate
}

input BoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

type Calendar {
    _count: CalendarCount
    calendarDates(
        cursor: CalendarDateWhereUniqueInput
        distinct: [CalendarDateScalarFieldEnum!]
        orderBy: [CalendarDateOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarDateWhereInput
    ): [CalendarDate!]!
    endDate: DateTime
    friday: Boolean!
    monday: Boolean!
    saturday: Boolean!
    serviceId: String!
    startDate: DateTime
    sunday: Boolean!
    thursday: Boolean!
    trips(
        cursor: TripWhereUniqueInput
        distinct: [TripScalarFieldEnum!]
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): [Trip!]!
    tuesday: Boolean!
    wednesday: Boolean!
}

type CalendarCount {
    calendarDates: Int!
    trips: Int!
}

type CalendarCountAggregate {
    _all: Int!
    endDate: Int!
    friday: Int!
    monday: Int!
    saturday: Int!
    serviceId: Int!
    startDate: Int!
    sunday: Int!
    thursday: Int!
    tuesday: Int!
    wednesday: Int!
}

input CalendarCountOrderByAggregateInput {
    endDate: SortOrder
    friday: SortOrder
    monday: SortOrder
    saturday: SortOrder
    serviceId: SortOrder
    startDate: SortOrder
    sunday: SortOrder
    thursday: SortOrder
    tuesday: SortOrder
    wednesday: SortOrder
}

type CalendarDate {
    date: DateTime!
    exceptionType: Boolean!
    service: Calendar!
    serviceId: String!
}

type CalendarDateCountAggregate {
    _all: Int!
    date: Int!
    exceptionType: Int!
    serviceId: Int!
}

input CalendarDateCountOrderByAggregateInput {
    date: SortOrder
    exceptionType: SortOrder
    serviceId: SortOrder
}

type CalendarDateGroupBy {
    _count: CalendarDateCountAggregate
    _max: CalendarDateMaxAggregate
    _min: CalendarDateMinAggregate
    date: DateTime!
    exceptionType: Boolean!
    serviceId: String!
}

input CalendarDateListRelationFilter {
    every: CalendarDateWhereInput
    none: CalendarDateWhereInput
    some: CalendarDateWhereInput
}

type CalendarDateMaxAggregate {
    date: DateTime
    exceptionType: Boolean
    serviceId: String
}

input CalendarDateMaxOrderByAggregateInput {
    date: SortOrder
    exceptionType: SortOrder
    serviceId: SortOrder
}

type CalendarDateMinAggregate {
    date: DateTime
    exceptionType: Boolean
    serviceId: String
}

input CalendarDateMinOrderByAggregateInput {
    date: SortOrder
    exceptionType: SortOrder
    serviceId: SortOrder
}

input CalendarDateOrderByRelationAggregateInput {
    _count: SortOrder
}

input CalendarDateOrderByWithAggregationInput {
    _count: CalendarDateCountOrderByAggregateInput
    _max: CalendarDateMaxOrderByAggregateInput
    _min: CalendarDateMinOrderByAggregateInput
    date: SortOrder
    exceptionType: SortOrder
    serviceId: SortOrder
}

input CalendarDateOrderByWithRelationInput {
    date: SortOrder
    exceptionType: SortOrder
    service: CalendarOrderByWithRelationInput
    serviceId: SortOrder
}

enum CalendarDateScalarFieldEnum {
    date
    exceptionType
    serviceId
}

input CalendarDateScalarWhereWithAggregatesInput {
    AND: [CalendarDateScalarWhereWithAggregatesInput!]
    NOT: [CalendarDateScalarWhereWithAggregatesInput!]
    OR: [CalendarDateScalarWhereWithAggregatesInput!]
    date: DateTimeWithAggregatesFilter
    exceptionType: BoolWithAggregatesFilter
    serviceId: StringWithAggregatesFilter
}

input CalendarDateServiceIdDateCompoundUniqueInput {
    date: DateTime!
    serviceId: String!
}

input CalendarDateWhereInput {
    AND: [CalendarDateWhereInput!]
    NOT: [CalendarDateWhereInput!]
    OR: [CalendarDateWhereInput!]
    date: DateTimeFilter
    exceptionType: BoolFilter
    service: CalendarRelationFilter
    serviceId: StringFilter
}

input CalendarDateWhereUniqueInput {
    serviceId_date: CalendarDateServiceIdDateCompoundUniqueInput
}

type CalendarGroupBy {
    _count: CalendarCountAggregate
    _max: CalendarMaxAggregate
    _min: CalendarMinAggregate
    endDate: DateTime
    friday: Boolean!
    monday: Boolean!
    saturday: Boolean!
    serviceId: String!
    startDate: DateTime
    sunday: Boolean!
    thursday: Boolean!
    tuesday: Boolean!
    wednesday: Boolean!
}

type CalendarMaxAggregate {
    endDate: DateTime
    friday: Boolean
    monday: Boolean
    saturday: Boolean
    serviceId: String
    startDate: DateTime
    sunday: Boolean
    thursday: Boolean
    tuesday: Boolean
    wednesday: Boolean
}

input CalendarMaxOrderByAggregateInput {
    endDate: SortOrder
    friday: SortOrder
    monday: SortOrder
    saturday: SortOrder
    serviceId: SortOrder
    startDate: SortOrder
    sunday: SortOrder
    thursday: SortOrder
    tuesday: SortOrder
    wednesday: SortOrder
}

type CalendarMinAggregate {
    endDate: DateTime
    friday: Boolean
    monday: Boolean
    saturday: Boolean
    serviceId: String
    startDate: DateTime
    sunday: Boolean
    thursday: Boolean
    tuesday: Boolean
    wednesday: Boolean
}

input CalendarMinOrderByAggregateInput {
    endDate: SortOrder
    friday: SortOrder
    monday: SortOrder
    saturday: SortOrder
    serviceId: SortOrder
    startDate: SortOrder
    sunday: SortOrder
    thursday: SortOrder
    tuesday: SortOrder
    wednesday: SortOrder
}

input CalendarOrderByWithAggregationInput {
    _count: CalendarCountOrderByAggregateInput
    _max: CalendarMaxOrderByAggregateInput
    _min: CalendarMinOrderByAggregateInput
    endDate: SortOrder
    friday: SortOrder
    monday: SortOrder
    saturday: SortOrder
    serviceId: SortOrder
    startDate: SortOrder
    sunday: SortOrder
    thursday: SortOrder
    tuesday: SortOrder
    wednesday: SortOrder
}

input CalendarOrderByWithRelationInput {
    calendarDates: CalendarDateOrderByRelationAggregateInput
    endDate: SortOrder
    friday: SortOrder
    monday: SortOrder
    saturday: SortOrder
    serviceId: SortOrder
    startDate: SortOrder
    sunday: SortOrder
    thursday: SortOrder
    trips: TripOrderByRelationAggregateInput
    tuesday: SortOrder
    wednesday: SortOrder
}

input CalendarRelationFilter {
    is: CalendarWhereInput
    isNot: CalendarWhereInput
}

enum CalendarScalarFieldEnum {
    endDate
    friday
    monday
    saturday
    serviceId
    startDate
    sunday
    thursday
    tuesday
    wednesday
}

input CalendarScalarWhereWithAggregatesInput {
    AND: [CalendarScalarWhereWithAggregatesInput!]
    NOT: [CalendarScalarWhereWithAggregatesInput!]
    OR: [CalendarScalarWhereWithAggregatesInput!]
    endDate: DateTimeNullableWithAggregatesFilter
    friday: BoolWithAggregatesFilter
    monday: BoolWithAggregatesFilter
    saturday: BoolWithAggregatesFilter
    serviceId: StringWithAggregatesFilter
    startDate: DateTimeNullableWithAggregatesFilter
    sunday: BoolWithAggregatesFilter
    thursday: BoolWithAggregatesFilter
    tuesday: BoolWithAggregatesFilter
    wednesday: BoolWithAggregatesFilter
}

input CalendarWhereInput {
    AND: [CalendarWhereInput!]
    NOT: [CalendarWhereInput!]
    OR: [CalendarWhereInput!]
    calendarDates: CalendarDateListRelationFilter
    endDate: DateTimeNullableFilter
    friday: BoolFilter
    monday: BoolFilter
    saturday: BoolFilter
    serviceId: StringFilter
    startDate: DateTimeNullableFilter
    sunday: BoolFilter
    thursday: BoolFilter
    trips: TripListRelationFilter
    tuesday: BoolFilter
    wednesday: BoolFilter
}

input CalendarWhereUniqueInput {
    serviceId: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input DateTimeNullableFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeNullableFilter
    notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedDateTimeNullableFilter
    _min: NestedDateTimeNullableFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeNullableWithAggregatesFilter
    notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFilter {
    equals: Decimal
    gt: Decimal
    gte: Decimal
    in: [Decimal!]
    lt: Decimal
    lte: Decimal
    not: NestedDecimalFilter
    notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
    _avg: NestedDecimalFilter
    _count: NestedIntFilter
    _max: NestedDecimalFilter
    _min: NestedDecimalFilter
    _sum: NestedDecimalFilter
    equals: Decimal
    gt: Decimal
    gte: Decimal
    in: [Decimal!]
    lt: Decimal
    lte: Decimal
    not: NestedDecimalWithAggregatesFilter
    notIn: [Decimal!]
}

enum Direction {
    RETURN
    WAY
}

input EnumDirectionFilter {
    equals: Direction
    in: [Direction!]
    not: NestedEnumDirectionFilter
    notIn: [Direction!]
}

input EnumDirectionWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumDirectionFilter
    _min: NestedEnumDirectionFilter
    equals: Direction
    in: [Direction!]
    not: NestedEnumDirectionWithAggregatesFilter
    notIn: [Direction!]
}

input EnumRouteCategoryFilter {
    equals: RouteCategory
    in: [RouteCategory!]
    not: NestedEnumRouteCategoryFilter
    notIn: [RouteCategory!]
}

input EnumRouteCategoryWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRouteCategoryFilter
    _min: NestedEnumRouteCategoryFilter
    equals: RouteCategory
    in: [RouteCategory!]
    not: NestedEnumRouteCategoryWithAggregatesFilter
    notIn: [RouteCategory!]
}

input EnumRouteTypeFilter {
    equals: RouteType
    in: [RouteType!]
    not: NestedEnumRouteTypeFilter
    notIn: [RouteType!]
}

input EnumRouteTypeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRouteTypeFilter
    _min: NestedEnumRouteTypeFilter
    equals: RouteType
    in: [RouteType!]
    not: NestedEnumRouteTypeWithAggregatesFilter
    notIn: [RouteType!]
}

input EnumWheelchairAccessibleFilter {
    equals: WheelchairAccessible
    in: [WheelchairAccessible!]
    not: NestedEnumWheelchairAccessibleFilter
    notIn: [WheelchairAccessible!]
}

input EnumWheelchairAccessibleWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumWheelchairAccessibleFilter
    _min: NestedEnumWheelchairAccessibleFilter
    equals: WheelchairAccessible
    in: [WheelchairAccessible!]
    not: NestedEnumWheelchairAccessibleWithAggregatesFilter
    notIn: [WheelchairAccessible!]
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input IntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableFilter
    notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
    _avg: NestedFloatNullableFilter
    _count: NestedIntNullableFilter
    _max: NestedIntNullableFilter
    _min: NestedIntNullableFilter
    _sum: NestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input IntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input NestedBoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeNullableFilter
    notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedDateTimeNullableFilter
    _min: NestedDateTimeNullableFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeNullableWithAggregatesFilter
    notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

input NestedDecimalFilter {
    equals: Decimal
    gt: Decimal
    gte: Decimal
    in: [Decimal!]
    lt: Decimal
    lte: Decimal
    not: NestedDecimalFilter
    notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
    _avg: NestedDecimalFilter
    _count: NestedIntFilter
    _max: NestedDecimalFilter
    _min: NestedDecimalFilter
    _sum: NestedDecimalFilter
    equals: Decimal
    gt: Decimal
    gte: Decimal
    in: [Decimal!]
    lt: Decimal
    lte: Decimal
    not: NestedDecimalWithAggregatesFilter
    notIn: [Decimal!]
}

input NestedEnumDirectionFilter {
    equals: Direction
    in: [Direction!]
    not: NestedEnumDirectionFilter
    notIn: [Direction!]
}

input NestedEnumDirectionWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumDirectionFilter
    _min: NestedEnumDirectionFilter
    equals: Direction
    in: [Direction!]
    not: NestedEnumDirectionWithAggregatesFilter
    notIn: [Direction!]
}

input NestedEnumRouteCategoryFilter {
    equals: RouteCategory
    in: [RouteCategory!]
    not: NestedEnumRouteCategoryFilter
    notIn: [RouteCategory!]
}

input NestedEnumRouteCategoryWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRouteCategoryFilter
    _min: NestedEnumRouteCategoryFilter
    equals: RouteCategory
    in: [RouteCategory!]
    not: NestedEnumRouteCategoryWithAggregatesFilter
    notIn: [RouteCategory!]
}

input NestedEnumRouteTypeFilter {
    equals: RouteType
    in: [RouteType!]
    not: NestedEnumRouteTypeFilter
    notIn: [RouteType!]
}

input NestedEnumRouteTypeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRouteTypeFilter
    _min: NestedEnumRouteTypeFilter
    equals: RouteType
    in: [RouteType!]
    not: NestedEnumRouteTypeWithAggregatesFilter
    notIn: [RouteType!]
}

input NestedEnumWheelchairAccessibleFilter {
    equals: WheelchairAccessible
    in: [WheelchairAccessible!]
    not: NestedEnumWheelchairAccessibleFilter
    notIn: [WheelchairAccessible!]
}

input NestedEnumWheelchairAccessibleWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumWheelchairAccessibleFilter
    _min: NestedEnumWheelchairAccessibleFilter
    equals: WheelchairAccessible
    in: [WheelchairAccessible!]
    not: NestedEnumWheelchairAccessibleWithAggregatesFilter
    notIn: [WheelchairAccessible!]
}

input NestedFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatFilter
    notIn: [Float!]
}

input NestedFloatNullableFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatNullableFilter
    notIn: [Float!]
}

input NestedIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input NestedIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableFilter
    notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
    _avg: NestedFloatNullableFilter
    _count: NestedIntNullableFilter
    _max: NestedIntNullableFilter
    _min: NestedIntNullableFilter
    _sum: NestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input NestedStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

type Query {
    agencies(
        cursor: AgencyWhereUniqueInput
        distinct: [AgencyScalarFieldEnum!]
        orderBy: [AgencyOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: AgencyWhereInput
    ): [Agency!]!
    agency(where: AgencyWhereUniqueInput!): Agency
    aggregateAgency(
        cursor: AgencyWhereUniqueInput
        orderBy: [AgencyOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: AgencyWhereInput
    ): AggregateAgency!
    aggregateCalendar(
        cursor: CalendarWhereUniqueInput
        orderBy: [CalendarOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarWhereInput
    ): AggregateCalendar!
    aggregateCalendarDate(
        cursor: CalendarDateWhereUniqueInput
        orderBy: [CalendarDateOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarDateWhereInput
    ): AggregateCalendarDate!
    aggregateRoute(
        cursor: RouteWhereUniqueInput
        orderBy: [RouteOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: RouteWhereInput
    ): AggregateRoute!
    aggregateShape(
        cursor: ShapeWhereUniqueInput
        orderBy: [ShapeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeWhereInput
    ): AggregateShape!
    aggregateShapeSequence(
        cursor: ShapeSequenceWhereUniqueInput
        orderBy: [ShapeSequenceOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeSequenceWhereInput
    ): AggregateShapeSequence!
    aggregateStop(
        cursor: StopWhereUniqueInput
        orderBy: [StopOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopWhereInput
    ): AggregateStop!
    aggregateStopTime(
        cursor: StopTimeWhereUniqueInput
        orderBy: [StopTimeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): AggregateStopTime!
    aggregateTransfer(
        cursor: TransferWhereUniqueInput
        orderBy: [TransferOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): AggregateTransfer!
    aggregateTrip(
        cursor: TripWhereUniqueInput
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): AggregateTrip!
    calendar(where: CalendarWhereUniqueInput!): Calendar
    calendarDate(where: CalendarDateWhereUniqueInput!): CalendarDate
    calendarDates(
        cursor: CalendarDateWhereUniqueInput
        distinct: [CalendarDateScalarFieldEnum!]
        orderBy: [CalendarDateOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarDateWhereInput
    ): [CalendarDate!]!
    calendars(
        cursor: CalendarWhereUniqueInput
        distinct: [CalendarScalarFieldEnum!]
        orderBy: [CalendarOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarWhereInput
    ): [Calendar!]!
    findFirstAgency(
        cursor: AgencyWhereUniqueInput
        distinct: [AgencyScalarFieldEnum!]
        orderBy: [AgencyOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: AgencyWhereInput
    ): Agency
    findFirstCalendar(
        cursor: CalendarWhereUniqueInput
        distinct: [CalendarScalarFieldEnum!]
        orderBy: [CalendarOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarWhereInput
    ): Calendar
    findFirstCalendarDate(
        cursor: CalendarDateWhereUniqueInput
        distinct: [CalendarDateScalarFieldEnum!]
        orderBy: [CalendarDateOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: CalendarDateWhereInput
    ): CalendarDate
    findFirstRoute(
        cursor: RouteWhereUniqueInput
        distinct: [RouteScalarFieldEnum!]
        orderBy: [RouteOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: RouteWhereInput
    ): Route
    findFirstShape(
        cursor: ShapeWhereUniqueInput
        distinct: [ShapeScalarFieldEnum!]
        orderBy: [ShapeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeWhereInput
    ): Shape
    findFirstShapeSequence(
        cursor: ShapeSequenceWhereUniqueInput
        distinct: [ShapeSequenceScalarFieldEnum!]
        orderBy: [ShapeSequenceOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeSequenceWhereInput
    ): ShapeSequence
    findFirstStop(
        cursor: StopWhereUniqueInput
        distinct: [StopScalarFieldEnum!]
        orderBy: [StopOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopWhereInput
    ): Stop
    findFirstStopTime(
        cursor: StopTimeWhereUniqueInput
        distinct: [StopTimeScalarFieldEnum!]
        orderBy: [StopTimeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): StopTime
    findFirstTransfer(
        cursor: TransferWhereUniqueInput
        distinct: [TransferScalarFieldEnum!]
        orderBy: [TransferOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): Transfer
    findFirstTrip(
        cursor: TripWhereUniqueInput
        distinct: [TripScalarFieldEnum!]
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): Trip
    groupByAgency(
        by: [AgencyScalarFieldEnum!]!
        having: AgencyScalarWhereWithAggregatesInput
        orderBy: [AgencyOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: AgencyWhereInput
    ): [AgencyGroupBy!]!
    groupByCalendar(
        by: [CalendarScalarFieldEnum!]!
        having: CalendarScalarWhereWithAggregatesInput
        orderBy: [CalendarOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: CalendarWhereInput
    ): [CalendarGroupBy!]!
    groupByCalendarDate(
        by: [CalendarDateScalarFieldEnum!]!
        having: CalendarDateScalarWhereWithAggregatesInput
        orderBy: [CalendarDateOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: CalendarDateWhereInput
    ): [CalendarDateGroupBy!]!
    groupByRoute(
        by: [RouteScalarFieldEnum!]!
        having: RouteScalarWhereWithAggregatesInput
        orderBy: [RouteOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: RouteWhereInput
    ): [RouteGroupBy!]!
    groupByShape(
        by: [ShapeScalarFieldEnum!]!
        having: ShapeScalarWhereWithAggregatesInput
        orderBy: [ShapeOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: ShapeWhereInput
    ): [ShapeGroupBy!]!
    groupByShapeSequence(
        by: [ShapeSequenceScalarFieldEnum!]!
        having: ShapeSequenceScalarWhereWithAggregatesInput
        orderBy: [ShapeSequenceOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: ShapeSequenceWhereInput
    ): [ShapeSequenceGroupBy!]!
    groupByStop(
        by: [StopScalarFieldEnum!]!
        having: StopScalarWhereWithAggregatesInput
        orderBy: [StopOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: StopWhereInput
    ): [StopGroupBy!]!
    groupByStopTime(
        by: [StopTimeScalarFieldEnum!]!
        having: StopTimeScalarWhereWithAggregatesInput
        orderBy: [StopTimeOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): [StopTimeGroupBy!]!
    groupByTransfer(
        by: [TransferScalarFieldEnum!]!
        having: TransferScalarWhereWithAggregatesInput
        orderBy: [TransferOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): [TransferGroupBy!]!
    groupByTrip(
        by: [TripScalarFieldEnum!]!
        having: TripScalarWhereWithAggregatesInput
        orderBy: [TripOrderByWithAggregationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): [TripGroupBy!]!
    route(where: RouteWhereUniqueInput!): Route
    routes(
        cursor: RouteWhereUniqueInput
        distinct: [RouteScalarFieldEnum!]
        orderBy: [RouteOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: RouteWhereInput
    ): [Route!]!
    shape(where: ShapeWhereUniqueInput!): Shape
    shapeSequence(where: ShapeSequenceWhereUniqueInput!): ShapeSequence
    shapeSequences(
        cursor: ShapeSequenceWhereUniqueInput
        distinct: [ShapeSequenceScalarFieldEnum!]
        orderBy: [ShapeSequenceOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeSequenceWhereInput
    ): [ShapeSequence!]!
    shapes(
        cursor: ShapeWhereUniqueInput
        distinct: [ShapeScalarFieldEnum!]
        orderBy: [ShapeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeWhereInput
    ): [Shape!]!
    stop(where: StopWhereUniqueInput!): Stop
    stopTime(where: StopTimeWhereUniqueInput!): StopTime
    stopTimes(
        cursor: StopTimeWhereUniqueInput
        distinct: [StopTimeScalarFieldEnum!]
        orderBy: [StopTimeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): [StopTime!]!
    stops(
        cursor: StopWhereUniqueInput
        distinct: [StopScalarFieldEnum!]
        orderBy: [StopOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopWhereInput
    ): [Stop!]!
    transfer(where: TransferWhereUniqueInput!): Transfer
    transfers(
        cursor: TransferWhereUniqueInput
        distinct: [TransferScalarFieldEnum!]
        orderBy: [TransferOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): [Transfer!]!
    trip(where: TripWhereUniqueInput!): Trip
    trips(
        cursor: TripWhereUniqueInput
        distinct: [TripScalarFieldEnum!]
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): [Trip!]!
}

enum QueryMode {
    default
    insensitive
}

type Route {
    _count: RouteCount
    agency: Agency!
    agencyId: Int!
    category: RouteCategory!
    routeColor: String
    routeId: String!
    routeLongName: String!
    routeShortName: String!
    routeTextColor: String
    routeType: RouteType!
    trips(
        cursor: TripWhereUniqueInput
        distinct: [TripScalarFieldEnum!]
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): [Trip!]!
}

type RouteAvgAggregate {
    agencyId: Float
}

input RouteAvgOrderByAggregateInput {
    agencyId: SortOrder
}

enum RouteCategory {
    SUBURBAN
    URBAN
}

type RouteCount {
    trips: Int!
}

type RouteCountAggregate {
    _all: Int!
    agencyId: Int!
    category: Int!
    routeColor: Int!
    routeId: Int!
    routeLongName: Int!
    routeShortName: Int!
    routeTextColor: Int!
    routeType: Int!
}

input RouteCountOrderByAggregateInput {
    agencyId: SortOrder
    category: SortOrder
    routeColor: SortOrder
    routeId: SortOrder
    routeLongName: SortOrder
    routeShortName: SortOrder
    routeTextColor: SortOrder
    routeType: SortOrder
}

type RouteGroupBy {
    _avg: RouteAvgAggregate
    _count: RouteCountAggregate
    _max: RouteMaxAggregate
    _min: RouteMinAggregate
    _sum: RouteSumAggregate
    agencyId: Int!
    category: RouteCategory!
    routeColor: String
    routeId: String!
    routeLongName: String!
    routeShortName: String!
    routeTextColor: String
    routeType: RouteType!
}

input RouteListRelationFilter {
    every: RouteWhereInput
    none: RouteWhereInput
    some: RouteWhereInput
}

type RouteMaxAggregate {
    agencyId: Int
    category: RouteCategory
    routeColor: String
    routeId: String
    routeLongName: String
    routeShortName: String
    routeTextColor: String
    routeType: RouteType
}

input RouteMaxOrderByAggregateInput {
    agencyId: SortOrder
    category: SortOrder
    routeColor: SortOrder
    routeId: SortOrder
    routeLongName: SortOrder
    routeShortName: SortOrder
    routeTextColor: SortOrder
    routeType: SortOrder
}

type RouteMinAggregate {
    agencyId: Int
    category: RouteCategory
    routeColor: String
    routeId: String
    routeLongName: String
    routeShortName: String
    routeTextColor: String
    routeType: RouteType
}

input RouteMinOrderByAggregateInput {
    agencyId: SortOrder
    category: SortOrder
    routeColor: SortOrder
    routeId: SortOrder
    routeLongName: SortOrder
    routeShortName: SortOrder
    routeTextColor: SortOrder
    routeType: SortOrder
}

input RouteOrderByRelationAggregateInput {
    _count: SortOrder
}

input RouteOrderByWithAggregationInput {
    _avg: RouteAvgOrderByAggregateInput
    _count: RouteCountOrderByAggregateInput
    _max: RouteMaxOrderByAggregateInput
    _min: RouteMinOrderByAggregateInput
    _sum: RouteSumOrderByAggregateInput
    agencyId: SortOrder
    category: SortOrder
    routeColor: SortOrder
    routeId: SortOrder
    routeLongName: SortOrder
    routeShortName: SortOrder
    routeTextColor: SortOrder
    routeType: SortOrder
}

input RouteOrderByWithRelationInput {
    agency: AgencyOrderByWithRelationInput
    agencyId: SortOrder
    category: SortOrder
    routeColor: SortOrder
    routeId: SortOrder
    routeLongName: SortOrder
    routeShortName: SortOrder
    routeTextColor: SortOrder
    routeType: SortOrder
    trips: TripOrderByRelationAggregateInput
}

input RouteRelationFilter {
    is: RouteWhereInput
    isNot: RouteWhereInput
}

enum RouteScalarFieldEnum {
    agencyId
    category
    routeColor
    routeId
    routeLongName
    routeShortName
    routeTextColor
    routeType
}

input RouteScalarWhereWithAggregatesInput {
    AND: [RouteScalarWhereWithAggregatesInput!]
    NOT: [RouteScalarWhereWithAggregatesInput!]
    OR: [RouteScalarWhereWithAggregatesInput!]
    agencyId: IntWithAggregatesFilter
    category: EnumRouteCategoryWithAggregatesFilter
    routeColor: StringNullableWithAggregatesFilter
    routeId: StringWithAggregatesFilter
    routeLongName: StringWithAggregatesFilter
    routeShortName: StringWithAggregatesFilter
    routeTextColor: StringNullableWithAggregatesFilter
    routeType: EnumRouteTypeWithAggregatesFilter
}

type RouteSumAggregate {
    agencyId: Int
}

input RouteSumOrderByAggregateInput {
    agencyId: SortOrder
}

enum RouteType {
    BUS
    CABLE_CAR
    FERRY
    GONDOLA
    ROPE_WAY
    SUBWAY
    TRAIN
    TRAM
}

input RouteWhereInput {
    AND: [RouteWhereInput!]
    NOT: [RouteWhereInput!]
    OR: [RouteWhereInput!]
    agency: AgencyRelationFilter
    agencyId: IntFilter
    category: EnumRouteCategoryFilter
    routeColor: StringNullableFilter
    routeId: StringFilter
    routeLongName: StringFilter
    routeShortName: StringFilter
    routeTextColor: StringNullableFilter
    routeType: EnumRouteTypeFilter
    trips: TripListRelationFilter
}

input RouteWhereUniqueInput {
    routeId: String
}

type Shape {
    _count: ShapeCount
    shapeId: String!
    shapeSequences(
        cursor: ShapeSequenceWhereUniqueInput
        distinct: [ShapeSequenceScalarFieldEnum!]
        orderBy: [ShapeSequenceOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: ShapeSequenceWhereInput
    ): [ShapeSequence!]!
    trips(
        cursor: TripWhereUniqueInput
        distinct: [TripScalarFieldEnum!]
        orderBy: [TripOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TripWhereInput
    ): [Trip!]!
}

type ShapeCount {
    shapeSequences: Int!
    trips: Int!
}

type ShapeCountAggregate {
    _all: Int!
    shapeId: Int!
}

input ShapeCountOrderByAggregateInput {
    shapeId: SortOrder
}

type ShapeGroupBy {
    _count: ShapeCountAggregate
    _max: ShapeMaxAggregate
    _min: ShapeMinAggregate
    shapeId: String!
}

type ShapeMaxAggregate {
    shapeId: String
}

input ShapeMaxOrderByAggregateInput {
    shapeId: SortOrder
}

type ShapeMinAggregate {
    shapeId: String
}

input ShapeMinOrderByAggregateInput {
    shapeId: SortOrder
}

input ShapeOrderByWithAggregationInput {
    _count: ShapeCountOrderByAggregateInput
    _max: ShapeMaxOrderByAggregateInput
    _min: ShapeMinOrderByAggregateInput
    shapeId: SortOrder
}

input ShapeOrderByWithRelationInput {
    shapeId: SortOrder
    shapeSequences: ShapeSequenceOrderByRelationAggregateInput
    trips: TripOrderByRelationAggregateInput
}

input ShapeRelationFilter {
    is: ShapeWhereInput
    isNot: ShapeWhereInput
}

enum ShapeScalarFieldEnum {
    shapeId
}

input ShapeScalarWhereWithAggregatesInput {
    AND: [ShapeScalarWhereWithAggregatesInput!]
    NOT: [ShapeScalarWhereWithAggregatesInput!]
    OR: [ShapeScalarWhereWithAggregatesInput!]
    shapeId: StringWithAggregatesFilter
}

type ShapeSequence {
    shape: Shape!
    shapeId: String!
    shapePtLat: Decimal!
    shapePtLon: Decimal!
    shapePtSequence: Int!
}

type ShapeSequenceAvgAggregate {
    shapePtLat: Decimal
    shapePtLon: Decimal
    shapePtSequence: Float
}

input ShapeSequenceAvgOrderByAggregateInput {
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

type ShapeSequenceCountAggregate {
    _all: Int!
    shapeId: Int!
    shapePtLat: Int!
    shapePtLon: Int!
    shapePtSequence: Int!
}

input ShapeSequenceCountOrderByAggregateInput {
    shapeId: SortOrder
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

type ShapeSequenceGroupBy {
    _avg: ShapeSequenceAvgAggregate
    _count: ShapeSequenceCountAggregate
    _max: ShapeSequenceMaxAggregate
    _min: ShapeSequenceMinAggregate
    _sum: ShapeSequenceSumAggregate
    shapeId: String!
    shapePtLat: Decimal!
    shapePtLon: Decimal!
    shapePtSequence: Int!
}

input ShapeSequenceListRelationFilter {
    every: ShapeSequenceWhereInput
    none: ShapeSequenceWhereInput
    some: ShapeSequenceWhereInput
}

type ShapeSequenceMaxAggregate {
    shapeId: String
    shapePtLat: Decimal
    shapePtLon: Decimal
    shapePtSequence: Int
}

input ShapeSequenceMaxOrderByAggregateInput {
    shapeId: SortOrder
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

type ShapeSequenceMinAggregate {
    shapeId: String
    shapePtLat: Decimal
    shapePtLon: Decimal
    shapePtSequence: Int
}

input ShapeSequenceMinOrderByAggregateInput {
    shapeId: SortOrder
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

input ShapeSequenceOrderByRelationAggregateInput {
    _count: SortOrder
}

input ShapeSequenceOrderByWithAggregationInput {
    _avg: ShapeSequenceAvgOrderByAggregateInput
    _count: ShapeSequenceCountOrderByAggregateInput
    _max: ShapeSequenceMaxOrderByAggregateInput
    _min: ShapeSequenceMinOrderByAggregateInput
    _sum: ShapeSequenceSumOrderByAggregateInput
    shapeId: SortOrder
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

input ShapeSequenceOrderByWithRelationInput {
    shape: ShapeOrderByWithRelationInput
    shapeId: SortOrder
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

enum ShapeSequenceScalarFieldEnum {
    shapeId
    shapePtLat
    shapePtLon
    shapePtSequence
}

input ShapeSequenceScalarWhereWithAggregatesInput {
    AND: [ShapeSequenceScalarWhereWithAggregatesInput!]
    NOT: [ShapeSequenceScalarWhereWithAggregatesInput!]
    OR: [ShapeSequenceScalarWhereWithAggregatesInput!]
    shapeId: StringWithAggregatesFilter
    shapePtLat: DecimalWithAggregatesFilter
    shapePtLon: DecimalWithAggregatesFilter
    shapePtSequence: IntWithAggregatesFilter
}

input ShapeSequenceShapeIdShapePtSequenceCompoundUniqueInput {
    shapeId: String!
    shapePtSequence: Int!
}

type ShapeSequenceSumAggregate {
    shapePtLat: Decimal
    shapePtLon: Decimal
    shapePtSequence: Int
}

input ShapeSequenceSumOrderByAggregateInput {
    shapePtLat: SortOrder
    shapePtLon: SortOrder
    shapePtSequence: SortOrder
}

input ShapeSequenceWhereInput {
    AND: [ShapeSequenceWhereInput!]
    NOT: [ShapeSequenceWhereInput!]
    OR: [ShapeSequenceWhereInput!]
    shape: ShapeRelationFilter
    shapeId: StringFilter
    shapePtLat: DecimalFilter
    shapePtLon: DecimalFilter
    shapePtSequence: IntFilter
}

input ShapeSequenceWhereUniqueInput {
    shapeId_shapePtSequence: ShapeSequenceShapeIdShapePtSequenceCompoundUniqueInput
}

input ShapeWhereInput {
    AND: [ShapeWhereInput!]
    NOT: [ShapeWhereInput!]
    OR: [ShapeWhereInput!]
    shapeId: StringFilter
    shapeSequences: ShapeSequenceListRelationFilter
    trips: TripListRelationFilter
}

input ShapeWhereUniqueInput {
    shapeId: String
}

enum SortOrder {
    asc
    desc
}

type Stop {
    _count: StopCount
    category: RouteCategory!
    stopCode: String!
    stopDesc: String!
    stopId: String!
    stopLat: Decimal!
    stopLon: Decimal!
    stopName: String!
    stopTimes(
        cursor: StopTimeWhereUniqueInput
        distinct: [StopTimeScalarFieldEnum!]
        orderBy: [StopTimeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): [StopTime!]!
    transfersFrom(
        cursor: TransferWhereUniqueInput
        distinct: [TransferScalarFieldEnum!]
        orderBy: [TransferOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): [Transfer!]!
    transfersTo(
        cursor: TransferWhereUniqueInput
        distinct: [TransferScalarFieldEnum!]
        orderBy: [TransferOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: TransferWhereInput
    ): [Transfer!]!
    wheelchairBoarding: WheelchairAccessible!
    zoneId: Int
}

type StopAvgAggregate {
    stopLat: Decimal
    stopLon: Decimal
    zoneId: Float
}

input StopAvgOrderByAggregateInput {
    stopLat: SortOrder
    stopLon: SortOrder
    zoneId: SortOrder
}

type StopCount {
    stopTimes: Int!
    transfersFrom: Int!
    transfersTo: Int!
}

type StopCountAggregate {
    _all: Int!
    category: Int!
    stopCode: Int!
    stopDesc: Int!
    stopId: Int!
    stopLat: Int!
    stopLon: Int!
    stopName: Int!
    wheelchairBoarding: Int!
    zoneId: Int!
}

input StopCountOrderByAggregateInput {
    category: SortOrder
    stopCode: SortOrder
    stopDesc: SortOrder
    stopId: SortOrder
    stopLat: SortOrder
    stopLon: SortOrder
    stopName: SortOrder
    wheelchairBoarding: SortOrder
    zoneId: SortOrder
}

type StopGroupBy {
    _avg: StopAvgAggregate
    _count: StopCountAggregate
    _max: StopMaxAggregate
    _min: StopMinAggregate
    _sum: StopSumAggregate
    category: RouteCategory!
    stopCode: String!
    stopDesc: String!
    stopId: String!
    stopLat: Decimal!
    stopLon: Decimal!
    stopName: String!
    wheelchairBoarding: WheelchairAccessible!
    zoneId: Int
}

type StopMaxAggregate {
    category: RouteCategory
    stopCode: String
    stopDesc: String
    stopId: String
    stopLat: Decimal
    stopLon: Decimal
    stopName: String
    wheelchairBoarding: WheelchairAccessible
    zoneId: Int
}

input StopMaxOrderByAggregateInput {
    category: SortOrder
    stopCode: SortOrder
    stopDesc: SortOrder
    stopId: SortOrder
    stopLat: SortOrder
    stopLon: SortOrder
    stopName: SortOrder
    wheelchairBoarding: SortOrder
    zoneId: SortOrder
}

type StopMinAggregate {
    category: RouteCategory
    stopCode: String
    stopDesc: String
    stopId: String
    stopLat: Decimal
    stopLon: Decimal
    stopName: String
    wheelchairBoarding: WheelchairAccessible
    zoneId: Int
}

input StopMinOrderByAggregateInput {
    category: SortOrder
    stopCode: SortOrder
    stopDesc: SortOrder
    stopId: SortOrder
    stopLat: SortOrder
    stopLon: SortOrder
    stopName: SortOrder
    wheelchairBoarding: SortOrder
    zoneId: SortOrder
}

input StopOrderByWithAggregationInput {
    _avg: StopAvgOrderByAggregateInput
    _count: StopCountOrderByAggregateInput
    _max: StopMaxOrderByAggregateInput
    _min: StopMinOrderByAggregateInput
    _sum: StopSumOrderByAggregateInput
    category: SortOrder
    stopCode: SortOrder
    stopDesc: SortOrder
    stopId: SortOrder
    stopLat: SortOrder
    stopLon: SortOrder
    stopName: SortOrder
    wheelchairBoarding: SortOrder
    zoneId: SortOrder
}

input StopOrderByWithRelationInput {
    category: SortOrder
    stopCode: SortOrder
    stopDesc: SortOrder
    stopId: SortOrder
    stopLat: SortOrder
    stopLon: SortOrder
    stopName: SortOrder
    stopTimes: StopTimeOrderByRelationAggregateInput
    transfersFrom: TransferOrderByRelationAggregateInput
    transfersTo: TransferOrderByRelationAggregateInput
    wheelchairBoarding: SortOrder
    zoneId: SortOrder
}

input StopRelationFilter {
    is: StopWhereInput
    isNot: StopWhereInput
}

enum StopScalarFieldEnum {
    category
    stopCode
    stopDesc
    stopId
    stopLat
    stopLon
    stopName
    wheelchairBoarding
    zoneId
}

input StopScalarWhereWithAggregatesInput {
    AND: [StopScalarWhereWithAggregatesInput!]
    NOT: [StopScalarWhereWithAggregatesInput!]
    OR: [StopScalarWhereWithAggregatesInput!]
    category: EnumRouteCategoryWithAggregatesFilter
    stopCode: StringWithAggregatesFilter
    stopDesc: StringWithAggregatesFilter
    stopId: StringWithAggregatesFilter
    stopLat: DecimalWithAggregatesFilter
    stopLon: DecimalWithAggregatesFilter
    stopName: StringWithAggregatesFilter
    wheelchairBoarding: EnumWheelchairAccessibleWithAggregatesFilter
    zoneId: IntNullableWithAggregatesFilter
}

type StopSumAggregate {
    stopLat: Decimal
    stopLon: Decimal
    zoneId: Int
}

input StopSumOrderByAggregateInput {
    stopLat: SortOrder
    stopLon: SortOrder
    zoneId: SortOrder
}

type StopTime {
    arrivalTime: String!
    departureTime: String!
    stop: Stop!
    stopId: String!
    stopSequence: Int!
    trip: Trip!
    tripId: String!
}

type StopTimeAvgAggregate {
    stopSequence: Float
}

input StopTimeAvgOrderByAggregateInput {
    stopSequence: SortOrder
}

type StopTimeCountAggregate {
    _all: Int!
    arrivalTime: Int!
    departureTime: Int!
    stopId: Int!
    stopSequence: Int!
    tripId: Int!
}

input StopTimeCountOrderByAggregateInput {
    arrivalTime: SortOrder
    departureTime: SortOrder
    stopId: SortOrder
    stopSequence: SortOrder
    tripId: SortOrder
}

type StopTimeGroupBy {
    _avg: StopTimeAvgAggregate
    _count: StopTimeCountAggregate
    _max: StopTimeMaxAggregate
    _min: StopTimeMinAggregate
    _sum: StopTimeSumAggregate
    arrivalTime: String!
    departureTime: String!
    stopId: String!
    stopSequence: Int!
    tripId: String!
}

input StopTimeListRelationFilter {
    every: StopTimeWhereInput
    none: StopTimeWhereInput
    some: StopTimeWhereInput
}

type StopTimeMaxAggregate {
    arrivalTime: String
    departureTime: String
    stopId: String
    stopSequence: Int
    tripId: String
}

input StopTimeMaxOrderByAggregateInput {
    arrivalTime: SortOrder
    departureTime: SortOrder
    stopId: SortOrder
    stopSequence: SortOrder
    tripId: SortOrder
}

type StopTimeMinAggregate {
    arrivalTime: String
    departureTime: String
    stopId: String
    stopSequence: Int
    tripId: String
}

input StopTimeMinOrderByAggregateInput {
    arrivalTime: SortOrder
    departureTime: SortOrder
    stopId: SortOrder
    stopSequence: SortOrder
    tripId: SortOrder
}

input StopTimeOrderByRelationAggregateInput {
    _count: SortOrder
}

input StopTimeOrderByWithAggregationInput {
    _avg: StopTimeAvgOrderByAggregateInput
    _count: StopTimeCountOrderByAggregateInput
    _max: StopTimeMaxOrderByAggregateInput
    _min: StopTimeMinOrderByAggregateInput
    _sum: StopTimeSumOrderByAggregateInput
    arrivalTime: SortOrder
    departureTime: SortOrder
    stopId: SortOrder
    stopSequence: SortOrder
    tripId: SortOrder
}

input StopTimeOrderByWithRelationInput {
    arrivalTime: SortOrder
    departureTime: SortOrder
    stop: StopOrderByWithRelationInput
    stopId: SortOrder
    stopSequence: SortOrder
    trip: TripOrderByWithRelationInput
    tripId: SortOrder
}

enum StopTimeScalarFieldEnum {
    arrivalTime
    departureTime
    stopId
    stopSequence
    tripId
}

input StopTimeScalarWhereWithAggregatesInput {
    AND: [StopTimeScalarWhereWithAggregatesInput!]
    NOT: [StopTimeScalarWhereWithAggregatesInput!]
    OR: [StopTimeScalarWhereWithAggregatesInput!]
    arrivalTime: StringWithAggregatesFilter
    departureTime: StringWithAggregatesFilter
    stopId: StringWithAggregatesFilter
    stopSequence: IntWithAggregatesFilter
    tripId: StringWithAggregatesFilter
}

type StopTimeSumAggregate {
    stopSequence: Int
}

input StopTimeSumOrderByAggregateInput {
    stopSequence: SortOrder
}

input StopTimeTripIdStopSequenceCompoundUniqueInput {
    stopSequence: Int!
    tripId: String!
}

input StopTimeWhereInput {
    AND: [StopTimeWhereInput!]
    NOT: [StopTimeWhereInput!]
    OR: [StopTimeWhereInput!]
    arrivalTime: StringFilter
    departureTime: StringFilter
    stop: StopRelationFilter
    stopId: StringFilter
    stopSequence: IntFilter
    trip: TripRelationFilter
    tripId: StringFilter
}

input StopTimeWhereUniqueInput {
    tripId_stopSequence: StopTimeTripIdStopSequenceCompoundUniqueInput
}

input StopWhereInput {
    AND: [StopWhereInput!]
    NOT: [StopWhereInput!]
    OR: [StopWhereInput!]
    category: EnumRouteCategoryFilter
    stopCode: StringFilter
    stopDesc: StringFilter
    stopId: StringFilter
    stopLat: DecimalFilter
    stopLon: DecimalFilter
    stopName: StringFilter
    stopTimes: StopTimeListRelationFilter
    transfersFrom: TransferListRelationFilter
    transfersTo: TransferListRelationFilter
    wheelchairBoarding: EnumWheelchairAccessibleFilter
    zoneId: IntNullableFilter
}

input StopWhereUniqueInput {
    stopId: String
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input StringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

type Transfer {
    fromStop: Stop!
    fromStopId: String!
    minTransferTime: Int!
    toStop: Stop!
    toStopId: String!
    transferType: Int!
}

type TransferAvgAggregate {
    minTransferTime: Float
    transferType: Float
}

input TransferAvgOrderByAggregateInput {
    minTransferTime: SortOrder
    transferType: SortOrder
}

type TransferCountAggregate {
    _all: Int!
    fromStopId: Int!
    minTransferTime: Int!
    toStopId: Int!
    transferType: Int!
}

input TransferCountOrderByAggregateInput {
    fromStopId: SortOrder
    minTransferTime: SortOrder
    toStopId: SortOrder
    transferType: SortOrder
}

input TransferFromStopIdToStopIdCompoundUniqueInput {
    fromStopId: String!
    toStopId: String!
}

type TransferGroupBy {
    _avg: TransferAvgAggregate
    _count: TransferCountAggregate
    _max: TransferMaxAggregate
    _min: TransferMinAggregate
    _sum: TransferSumAggregate
    fromStopId: String!
    minTransferTime: Int!
    toStopId: String!
    transferType: Int!
}

input TransferListRelationFilter {
    every: TransferWhereInput
    none: TransferWhereInput
    some: TransferWhereInput
}

type TransferMaxAggregate {
    fromStopId: String
    minTransferTime: Int
    toStopId: String
    transferType: Int
}

input TransferMaxOrderByAggregateInput {
    fromStopId: SortOrder
    minTransferTime: SortOrder
    toStopId: SortOrder
    transferType: SortOrder
}

type TransferMinAggregate {
    fromStopId: String
    minTransferTime: Int
    toStopId: String
    transferType: Int
}

input TransferMinOrderByAggregateInput {
    fromStopId: SortOrder
    minTransferTime: SortOrder
    toStopId: SortOrder
    transferType: SortOrder
}

input TransferOrderByRelationAggregateInput {
    _count: SortOrder
}

input TransferOrderByWithAggregationInput {
    _avg: TransferAvgOrderByAggregateInput
    _count: TransferCountOrderByAggregateInput
    _max: TransferMaxOrderByAggregateInput
    _min: TransferMinOrderByAggregateInput
    _sum: TransferSumOrderByAggregateInput
    fromStopId: SortOrder
    minTransferTime: SortOrder
    toStopId: SortOrder
    transferType: SortOrder
}

input TransferOrderByWithRelationInput {
    fromStop: StopOrderByWithRelationInput
    fromStopId: SortOrder
    minTransferTime: SortOrder
    toStop: StopOrderByWithRelationInput
    toStopId: SortOrder
    transferType: SortOrder
}

enum TransferScalarFieldEnum {
    fromStopId
    minTransferTime
    toStopId
    transferType
}

input TransferScalarWhereWithAggregatesInput {
    AND: [TransferScalarWhereWithAggregatesInput!]
    NOT: [TransferScalarWhereWithAggregatesInput!]
    OR: [TransferScalarWhereWithAggregatesInput!]
    fromStopId: StringWithAggregatesFilter
    minTransferTime: IntWithAggregatesFilter
    toStopId: StringWithAggregatesFilter
    transferType: IntWithAggregatesFilter
}

type TransferSumAggregate {
    minTransferTime: Int
    transferType: Int
}

input TransferSumOrderByAggregateInput {
    minTransferTime: SortOrder
    transferType: SortOrder
}

input TransferWhereInput {
    AND: [TransferWhereInput!]
    NOT: [TransferWhereInput!]
    OR: [TransferWhereInput!]
    fromStop: StopRelationFilter
    fromStopId: StringFilter
    minTransferTime: IntFilter
    toStop: StopRelationFilter
    toStopId: StringFilter
    transferType: IntFilter
}

input TransferWhereUniqueInput {
    fromStopId_toStopId: TransferFromStopIdToStopIdCompoundUniqueInput
}

type Trip {
    _count: TripCount
    category: RouteCategory!
    directionId: Direction!
    route: Route!
    routeId: String!
    service: Calendar!
    serviceId: String!
    shape: Shape
    shapeId: String
    stopTimes(
        cursor: StopTimeWhereUniqueInput
        distinct: [StopTimeScalarFieldEnum!]
        orderBy: [StopTimeOrderByWithRelationInput!]
        skip: Int
        take: Int
        where: StopTimeWhereInput
    ): [StopTime!]!
    tripHeadsign: String!
    tripId: String!
    wheelchairAccessible: WheelchairAccessible!
}

type TripCount {
    stopTimes: Int!
}

type TripCountAggregate {
    _all: Int!
    category: Int!
    directionId: Int!
    routeId: Int!
    serviceId: Int!
    shapeId: Int!
    tripHeadsign: Int!
    tripId: Int!
    wheelchairAccessible: Int!
}

input TripCountOrderByAggregateInput {
    category: SortOrder
    directionId: SortOrder
    routeId: SortOrder
    serviceId: SortOrder
    shapeId: SortOrder
    tripHeadsign: SortOrder
    tripId: SortOrder
    wheelchairAccessible: SortOrder
}

type TripGroupBy {
    _count: TripCountAggregate
    _max: TripMaxAggregate
    _min: TripMinAggregate
    category: RouteCategory!
    directionId: Direction!
    routeId: String!
    serviceId: String!
    shapeId: String
    tripHeadsign: String!
    tripId: String!
    wheelchairAccessible: WheelchairAccessible!
}

input TripListRelationFilter {
    every: TripWhereInput
    none: TripWhereInput
    some: TripWhereInput
}

type TripMaxAggregate {
    category: RouteCategory
    directionId: Direction
    routeId: String
    serviceId: String
    shapeId: String
    tripHeadsign: String
    tripId: String
    wheelchairAccessible: WheelchairAccessible
}

input TripMaxOrderByAggregateInput {
    category: SortOrder
    directionId: SortOrder
    routeId: SortOrder
    serviceId: SortOrder
    shapeId: SortOrder
    tripHeadsign: SortOrder
    tripId: SortOrder
    wheelchairAccessible: SortOrder
}

type TripMinAggregate {
    category: RouteCategory
    directionId: Direction
    routeId: String
    serviceId: String
    shapeId: String
    tripHeadsign: String
    tripId: String
    wheelchairAccessible: WheelchairAccessible
}

input TripMinOrderByAggregateInput {
    category: SortOrder
    directionId: SortOrder
    routeId: SortOrder
    serviceId: SortOrder
    shapeId: SortOrder
    tripHeadsign: SortOrder
    tripId: SortOrder
    wheelchairAccessible: SortOrder
}

input TripOrderByRelationAggregateInput {
    _count: SortOrder
}

input TripOrderByWithAggregationInput {
    _count: TripCountOrderByAggregateInput
    _max: TripMaxOrderByAggregateInput
    _min: TripMinOrderByAggregateInput
    category: SortOrder
    directionId: SortOrder
    routeId: SortOrder
    serviceId: SortOrder
    shapeId: SortOrder
    tripHeadsign: SortOrder
    tripId: SortOrder
    wheelchairAccessible: SortOrder
}

input TripOrderByWithRelationInput {
    category: SortOrder
    directionId: SortOrder
    route: RouteOrderByWithRelationInput
    routeId: SortOrder
    service: CalendarOrderByWithRelationInput
    serviceId: SortOrder
    shape: ShapeOrderByWithRelationInput
    shapeId: SortOrder
    stopTimes: StopTimeOrderByRelationAggregateInput
    tripHeadsign: SortOrder
    tripId: SortOrder
    wheelchairAccessible: SortOrder
}

input TripRelationFilter {
    is: TripWhereInput
    isNot: TripWhereInput
}

enum TripScalarFieldEnum {
    category
    directionId
    routeId
    serviceId
    shapeId
    tripHeadsign
    tripId
    wheelchairAccessible
}

input TripScalarWhereWithAggregatesInput {
    AND: [TripScalarWhereWithAggregatesInput!]
    NOT: [TripScalarWhereWithAggregatesInput!]
    OR: [TripScalarWhereWithAggregatesInput!]
    category: EnumRouteCategoryWithAggregatesFilter
    directionId: EnumDirectionWithAggregatesFilter
    routeId: StringWithAggregatesFilter
    serviceId: StringWithAggregatesFilter
    shapeId: StringNullableWithAggregatesFilter
    tripHeadsign: StringWithAggregatesFilter
    tripId: StringWithAggregatesFilter
    wheelchairAccessible: EnumWheelchairAccessibleWithAggregatesFilter
}

input TripWhereInput {
    AND: [TripWhereInput!]
    NOT: [TripWhereInput!]
    OR: [TripWhereInput!]
    category: EnumRouteCategoryFilter
    directionId: EnumDirectionFilter
    route: RouteRelationFilter
    routeId: StringFilter
    service: CalendarRelationFilter
    serviceId: StringFilter
    shape: ShapeRelationFilter
    shapeId: StringNullableFilter
    stopTimes: StopTimeListRelationFilter
    tripHeadsign: StringFilter
    tripId: StringFilter
    wheelchairAccessible: EnumWheelchairAccessibleFilter
}

input TripWhereUniqueInput {
    tripId: String
}

enum WheelchairAccessible {
    NO
    NO_INFO
    YES
}
